<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tulip Tackers – Markermeer Party-Schleife (Seekarte, stabil)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: #f3f6fb; color: #0f213f; font: 15px/1.5 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
    body { display: flex; }
    .app { display: flex; flex: 1 1 auto; min-height: 100vh; width: 100%; }
    .sidebar { width: 320px; max-width: 360px; background: #ffffff; padding: 28px 24px 36px; display: flex; flex-direction: column; gap: 20px; box-shadow: 16px 0 40px rgba(12, 40, 80, 0.12); z-index: 1000; }
    .sidebar h1 { margin: 0; font-size: 26px; letter-spacing: 0.02em; }
    .sidebar p { margin: 0; color: #42516a; }
    .sidebar .intro { font-size: 15px; }
    .route-details { display: flex; flex-direction: column; gap: 18px; }
    .sea-note { font-size: 12px; color: #61718f; line-height: 1.5; border-top: 1px solid rgba(30, 60, 120, 0.12); padding-top: 12px; margin-top: auto; }
    .route-card { background: linear-gradient(135deg, rgba(37, 102, 233, 0.08), rgba(104, 176, 255, 0.06)); border: 1px solid rgba(37, 102, 233, 0.18); border-radius: 18px; padding: 20px 20px 18px; display: flex; flex-direction: column; gap: 16px; box-shadow: 0 10px 30px rgba(25, 68, 130, 0.12); }
    .route-card__header { display: flex; flex-direction: column; gap: 4px; }
    .route-card__header h2 { margin: 6px 0 4px; font-size: 18px; line-height: 1.3; }
    .route-card__header p { margin: 0; font-size: 13px; text-transform: uppercase; letter-spacing: 0.06em; color: #304c78; }
    .badge { display: inline-flex; align-items: center; gap: 6px; font-size: 11px; font-weight: 600; letter-spacing: 0.1em; text-transform: uppercase; color: #1b4fd8; background: rgba(37, 102, 233, 0.12); border-radius: 999px; padding: 4px 10px; }
    .leg-list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 14px; }
    .leg-list li { display: flex; flex-direction: column; gap: 4px; padding: 10px 12px; background: rgba(255, 255, 255, 0.75); border: 1px solid rgba(37, 102, 233, 0.12); border-radius: 12px; cursor: pointer; transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease; outline: none; }
    .leg-list li:hover, .leg-list li:focus { border-color: rgba(37, 102, 233, 0.4); box-shadow: 0 8px 18px rgba(25, 68, 130, 0.16); transform: translateY(-1px); }
    .leg-list li.is-active { border-color: rgba(37, 102, 233, 0.55); box-shadow: 0 10px 24px rgba(25, 68, 130, 0.2); transform: translateY(-2px); }
    .leg-name { font-weight: 600; color: #0f2350; }
    .leg-meta { display: flex; justify-content: space-between; font-size: 13px; color: #486186; }
    .leg-distance { font-weight: 600; color: #123a80; }
    .leg-duration { font-variant-numeric: tabular-nums; }
    .map-wrap { position: relative; flex: 1; }
    #map { height: 100%; width: 100%; min-height: 100vh; background: #e4edf8; }
    .toolbar { position: absolute; top: 24px; right: 28px; z-index: 1000; display: flex; gap: 8px; background: rgba(255, 255, 255, 0.95); border: 1px solid rgba(30, 60, 120, 0.18); box-shadow: 0 10px 25px rgba(16, 40, 84, 0.12); border-radius: 14px; padding: 6px; backdrop-filter: blur(4px); }
    .toolbar button { cursor: pointer; border: 1px solid rgba(30, 60, 120, 0.18); background: #fff; padding: 8px 14px; border-radius: 10px; font-weight: 600; color: #1b2f53; transition: all 0.15s ease; }
    .toolbar button:hover { border-color: #1f58ff; color: #1f58ff; }
    .toolbar button.active { background: #2b7bff; color: #fff; border-color: #1f58ff; box-shadow: 0 8px 16px rgba(31, 88, 255, 0.3); }
    .legend { position: absolute; bottom: 24px; right: 28px; background: rgba(255, 255, 255, 0.94); border: 1px solid rgba(30, 60, 120, 0.16); border-radius: 12px; padding: 14px 16px; box-shadow: 0 12px 24px rgba(16, 38, 82, 0.15); font-size: 13px; line-height: 1.4; max-width: 300px; }
    .legend strong { display: block; margin-bottom: 6px; color: #0f2350; }
    .legend .swatch, .legend .swatch-alt { display: inline-block; width: 24px; height: 6px; margin-right: 6px; vertical-align: middle; border-radius: 3px; box-shadow: 0 0 0 1px rgba(21, 101, 192, 0.25); }
    .legend .swatch { background: #1565c0; }
    .legend .swatch-alt { background: #1565c0; border-bottom: 2px dashed #1565c0; box-shadow: none; }
    .lbl { background: rgba(255, 255, 255, 0.92); border: 1px solid rgba(37, 102, 233, 0.25); border-radius: 8px; padding: 4px 7px; font-size: 12px; color: #1a2d4f; box-shadow: 0 6px 18px rgba(16, 38, 82, 0.2); white-space: nowrap; }
    .lbl small { color: #486186; }
    @media (max-width: 900px) {
      .app { flex-direction: column; }
      .sidebar { width: 100%; max-width: none; box-shadow: none; border-bottom: 1px solid rgba(30, 60, 120, 0.12); border-radius: 0; }
      .map-wrap { min-height: 70vh; }
      #map { min-height: 70vh; }
      .toolbar { left: 50%; right: auto; transform: translateX(-50%); top: 18px; }
      .legend { left: 50%; right: auto; transform: translateX(-50%); bottom: 18px; }
    }
    @media (max-width: 520px) {
      .toolbar { flex-wrap: wrap; gap: 4px; padding: 6px 10px; }
      .toolbar button { flex: 1 0 120px; }
      .legend { width: calc(100% - 32px); max-width: none; }
      .leg-meta { flex-direction: column; gap: 2px; align-items: flex-start; }
      #map { min-height: 60vh; }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar">
      <h1>Tulip Tackers</h1>
      <p class="intro">Markermeer Routenplanung mit echten See-Distanzen. Wähle deine Party-Schleife oder den Urk-Umweg und sieh sofort, wie viele Seemeilen pro Schlag anstehen.</p>
      <div id="routeDetails" class="route-details"></div>
      <div class="sea-note">Distanzberechnung via Haversine über alle Wegpunkte. Reisezeiten kalkuliert für 6–7 kn. Basemap: Carto Voyager &amp; OSM · Overlay: OpenSeaMap.</div>
    </aside>
    <div class="map-wrap">
      <div id="map"></div>
      <div class="toolbar">
        <button id="btnA" class="active" title="Zeige Party-Schleife (Volendam)">Route A</button>
        <button id="btnB" title="Zeige Alternative über Urk">Route B</button>
      </div>
      <div class="legend">
        <strong>Tulip Tackers – Seekarte</strong>
        <span class="swatch"></span> Party-Schleife: Lemmer → Hoorn → Amsterdam → Volendam → Lemmer<br/>
        <span class="swatch-alt"></span> Alternative: Amsterdam → Urk → Lemmer<br/>
        Basemap: Carto Voyager (Fallback: OSM) · Overlay: OpenSeaMap Seamarks
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // ---- Häfen ----
    const ports = {
      Lemmer:    [52.846, 5.708],
      Hoorn:     [52.643, 5.071],
      Amsterdam: [52.383, 4.900], // grob Sixhaven
      Volendam:  [52.495, 5.073],
      Urk:       [52.664, 5.604]
    };

    // ---- Route-Definition mit Waypoints ----
    const NM_FROM_KM = 1 / 1.852;
    const toRad = v => v * Math.PI / 180;
    const haversineKm = (a, b) => {
      const [lat1, lon1] = a;
      const [lat2, lon2] = b;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const s = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s));
      return 6371.0088 * c;
    };
    const distanceNm = points => {
      let km = 0;
      for (let i = 1; i < points.length; i += 1) {
        km += haversineKm(points[i - 1], points[i]);
      }
      return km * NM_FROM_KM;
    };

    const routes = {
      A: {
        id: 'A',
        label: 'Route A',
        title: 'Party-Schleife: Lemmer → Hoorn → Amsterdam → Volendam → Lemmer',
        color: '#1565c0',
        dashed: false,
        legs: [
          {
            from: 'Lemmer', to: 'Hoorn',
            points: [
              ports.Lemmer,
              [52.820, 5.530], [52.750, 5.350], [52.662, 5.200],
              ports.Hoorn
            ]
          },
          {
            from: 'Hoorn', to: 'Amsterdam',
            points: [
              ports.Hoorn,
              [52.610, 5.100], [52.580, 5.050], [52.510, 5.030],
              [52.450, 5.000], [52.400, 4.950],
              [52.372, 4.985],
              ports.Amsterdam
            ]
          },
          {
            from: 'Amsterdam', to: 'Volendam',
            points: [
              ports.Amsterdam,
              [52.372, 4.985], [52.470, 5.030], [52.495, 5.060],
              ports.Volendam
            ]
          },
          {
            from: 'Volendam', to: 'Lemmer',
            points: [
              ports.Volendam,
              [52.530, 5.100], [52.600, 5.200], [52.680, 5.400], [52.780, 5.550],
              ports.Lemmer
            ]
          }
        ]
      },
      B: {
        id: 'B',
        label: 'Route B',
        title: 'Alternative via Urk: Amsterdam → Urk → Lemmer',
        color: '#1565c0',
        dashed: true,
        legs: [
          {
            from: 'Amsterdam', to: 'Urk',
            points: [
              ports.Amsterdam,
              [52.372, 4.985], [52.520, 5.050], [52.600, 5.250], [52.630, 5.350],
              ports.Urk
            ]
          },
          {
            from: 'Urk', to: 'Lemmer',
            points: [
              ports.Urk,
              [52.720, 5.520], [52.790, 5.600],
              ports.Lemmer
            ]
          }
        ]
      }
    };

    Object.values(routes).forEach(route => {
      let totalNm = 0;
      route.legs.forEach(leg => {
        const nm = distanceNm(leg.points);
        leg.distanceNm = parseFloat(nm.toFixed(1));
        leg.duration = {
          fast: (leg.distanceNm / 7).toFixed(1),
          slow: (leg.distanceNm / 6).toFixed(1)
        };
        totalNm += leg.distanceNm;
      });
      route.totalNm = parseFloat(totalNm.toFixed(1));
      route.duration = {
        fast: (route.totalNm / 7).toFixed(1),
        slow: (route.totalNm / 6).toFixed(1)
      };
    });

    // ---- Karte + stabile Tiles mit Fallback ----
    const map = L.map('map', { zoomControl:true });
    map.attributionControl.setPrefix('');
    const carto = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png', {
      maxZoom: 19, attribution: '&copy; OpenStreetMap & CARTO'
    });
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, attribution: '&copy; OpenStreetMap-Mitwirkende'
    });
    // Start mit Carto; fallback auf OSM wenn ein Fehler auftritt
    carto.on('tileerror', () => { if (!map.hasLayer(osm)) { map.addLayer(osm); map.removeLayer(carto); } });
    carto.addTo(map);

    // Seamarks-Overlay (OpenSeaMap) – zeigt Tonnen/Leuchtfeuer/Fahrwasser
    const seamarks = L.tileLayer('https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
      maxZoom: 18, opacity: 0.95, attribution: '&copy; OpenSeaMap Contributors'
    }).addTo(map);

    L.control.layers(
      { 'Carto Voyager': carto, 'OpenStreetMap': osm },
      { 'OpenSeaMap Seamarks': seamarks },
      { collapsed: true }
    ).addTo(map);

    L.control.scale({ imperial:false }).addTo(map);

    // Hafenmarker
    const harborInfo = {
      Lemmer: 'Base: Enjoy Sailing',
      Hoorn: 'Grashaven • Binnenhaven/Oude Doelenkade',
      Amsterdam: 'Sixhaven / Amsterdam Marina · Oranjesluizen',
      Volendam: 'Marina Volendam',
      Urk: 'Urkerhaven'
    };
    const portMarkers = Object.entries(ports).map(([name, latlng]) =>
      L.marker(latlng).bindPopup(`<b>${name}</b><br/>${harborInfo[name]||''}`).bindTooltip(name)
    );

    const durationRange = duration => `${duration.fast}–${duration.slow} h`;

    const routeGroups = {};
    Object.values(routes).forEach(route => {
      const layers = [];
      route.legs.forEach(leg => {
        const polyline = L.polyline(leg.points, {
          color: route.color,
          weight: 5,
          opacity: 0.95,
          lineCap: 'round',
          lineJoin: 'round',
          dashArray: route.dashed ? '10,8' : null
        });
        polyline.bindTooltip(`${leg.from} → ${leg.to} · ${leg.distanceNm} sm`, { sticky: true });
        const html = `<div class="lbl"><b>${leg.from} → ${leg.to}</b><br/>${leg.distanceNm} sm · <small>${durationRange(leg.duration)} @ 7–6 kn</small></div>`;
        const center = polyline.getBounds().getCenter();
        const label = L.marker(center, { interactive: false, icon: L.divIcon({ className: '', html }) });
        leg.layer = polyline;
        leg.labelMarker = label;
        layers.push(polyline, label);
      });
      routeGroups[route.id] = L.featureGroup(layers);
    });
    portMarkers.forEach(m => m.addTo(map));

    const btnA = document.getElementById('btnA');
    const btnB = document.getElementById('btnB');
    const buttons = { A: btnA, B: btnB };
    const detailsEl = document.getElementById('routeDetails');

    let highlightedLeg = { routeId: null, index: null };

    function renderRouteDetails(route) {
      if (!detailsEl) return;
      const list = route.legs.map((leg, idx) => `
        <li data-leg-index="${idx}" tabindex="0">
          <div class="leg-name">${leg.from} → ${leg.to}</div>
          <div class="leg-meta">
            <span class="leg-distance">${leg.distanceNm} sm</span>
            <span class="leg-duration">${durationRange(leg.duration)} · 7–6 kn</span>
          </div>
        </li>
      `).join('');
      detailsEl.innerHTML = `
        <div class="route-card">
          <div class="route-card__header">
            <span class="badge">${route.label}</span>
            <h2>${route.title}</h2>
            <p>${route.totalNm} sm gesamt · ${durationRange(route.duration)} @ 7–6 kn</p>
          </div>
          <ul class="leg-list">${list}</ul>
        </div>
      `;
    }

    function clearHighlightedLeg() {
      if (highlightedLeg.routeId === null) return;
      const route = routes[highlightedLeg.routeId];
      const leg = route?.legs?.[highlightedLeg.index];
      if (leg?.layer) {
        leg.layer.setStyle({ weight: 5, opacity: 0.95 });
      }
      if (highlightedLeg.routeId === activeRouteId && detailsEl) {
        const item = detailsEl.querySelector(`li[data-leg-index="${highlightedLeg.index}"]`);
        if (item) item.classList.remove('is-active');
      }
      highlightedLeg = { routeId: null, index: null };
    }

    function highlightLeg(routeId, index) {
      if (highlightedLeg.routeId === routeId && highlightedLeg.index === index) return;
      clearHighlightedLeg();
      const route = routes[routeId];
      const leg = route?.legs?.[index];
      if (!leg || !leg.layer) return;
      leg.layer.setStyle({ weight: 7, opacity: 1 });
      leg.layer.bringToFront();
      highlightedLeg = { routeId, index };
      if (routeId === activeRouteId && detailsEl) {
        const item = detailsEl.querySelector(`li[data-leg-index="${index}"]`);
        if (item) item.classList.add('is-active');
      }
    }

    function fitTo(layer) {
      map.fitBounds(layer.getBounds().pad(0.2));
    }

    let activeRouteId = 'A';
    map.addLayer(routeGroups[activeRouteId]);
    fitTo(routeGroups[activeRouteId]);
    buttons[activeRouteId].classList.add('active');
    renderRouteDetails(routes[activeRouteId]);

    function activateRoute(id) {
      if (id === activeRouteId) return;
      map.removeLayer(routeGroups[activeRouteId]);
      buttons[activeRouteId].classList.remove('active');
      clearHighlightedLeg();
      activeRouteId = id;
      map.addLayer(routeGroups[id]);
      buttons[id].classList.add('active');
      fitTo(routeGroups[id]);
      renderRouteDetails(routes[id]);
    }

    btnA.addEventListener('click', () => activateRoute('A'));
    btnB.addEventListener('click', () => activateRoute('B'));

    if (detailsEl) {
      detailsEl.addEventListener('mouseover', event => {
        const item = event.target.closest('li[data-leg-index]');
        if (!item) return;
        highlightLeg(activeRouteId, Number(item.dataset.legIndex));
      });
      detailsEl.addEventListener('focusin', event => {
        const item = event.target.closest('li[data-leg-index]');
        if (!item) return;
        highlightLeg(activeRouteId, Number(item.dataset.legIndex));
      });
      detailsEl.addEventListener('mouseleave', () => {
        clearHighlightedLeg();
      });
      detailsEl.addEventListener('focusout', event => {
        if (detailsEl.contains(event.relatedTarget)) return;
        clearHighlightedLeg();
      });
    }
  </script>
</body>
</html>
