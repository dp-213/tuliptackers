<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tulip Tackers – Markermeer Cruising Loop (Hoorn · Urk)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: #f3f6fb; color: #0f213f; font: 15px/1.5 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
    body { display: flex; }
    .app { display: flex; flex: 1 1 auto; min-height: 100vh; width: 100%; }
    .sidebar { width: 340px; max-width: 380px; background: #ffffff; padding: 26px 24px 32px; display: flex; flex-direction: column; gap: 18px; box-shadow: 16px 0 40px rgba(12, 40, 80, 0.12); z-index: 1000; overflow-y: auto; }
    .sidebar h1 { margin: 0; font-size: 26px; letter-spacing: 0.02em; }
    .sidebar p { margin: 0; color: #42516a; }
    .sidebar .intro { font-size: 15px; }
    .field-label { font-size: 12px; letter-spacing: 0.08em; text-transform: uppercase; font-weight: 600; color: #486186; }
    #routeNameInput { border: 1px solid rgba(30, 60, 120, 0.18); border-radius: 10px; padding: 10px 12px; font-size: 14px; font-family: inherit; color: #0f213f; background: rgba(248, 250, 255, 0.9); }
    #routeNameInput:focus { outline: 2px solid rgba(31, 88, 255, 0.35); outline-offset: 1px; }
    .editor { display: flex; flex-direction: column; gap: 12px; padding: 16px 16px 18px; background: rgba(37, 102, 233, 0.06); border: 1px solid rgba(37, 102, 233, 0.18); border-radius: 16px; box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3); }
    .sidebar button { cursor: pointer; border: 1px solid rgba(30, 60, 120, 0.18); background: #fff; padding: 8px 12px; border-radius: 10px; font-weight: 600; color: #1b2f53; transition: all 0.15s ease; font-family: inherit; }
    .sidebar button:hover { border-color: #1f58ff; color: #1f58ff; }
    .editor-controls { display: flex; gap: 8px; flex-wrap: wrap; }
    .editor-controls button { flex: 1 0 150px; }
    .editor-controls button.is-armed { background: #2b7bff; color: #fff; border-color: #1f58ff; box-shadow: 0 8px 16px rgba(31, 88, 255, 0.3); }
    .editor-actions { display: flex; justify-content: space-between; gap: 10px; margin-top: 4px; }
    .editor-actions .secondary { background: rgba(31, 88, 255, 0.08); color: #1f58ff; border-color: rgba(31, 88, 255, 0.18); }
    .waypoint-list { display: flex; flex-direction: column; gap: 10px; max-height: 280px; overflow-y: auto; padding-right: 4px; }
    .waypoint-empty { font-size: 13px; color: #61718f; background: rgba(255, 255, 255, 0.86); border: 1px dashed rgba(37, 102, 233, 0.28); border-radius: 10px; padding: 12px; text-align: center; }
    .waypoint-row { display: grid; grid-template-columns: 26px minmax(0, 1fr) 112px 112px auto; align-items: center; gap: 6px; padding: 8px 10px; background: rgba(255, 255, 255, 0.92); border: 1px solid rgba(37, 102, 233, 0.14); border-radius: 12px; box-shadow: 0 4px 12px rgba(25, 68, 130, 0.08); }
    .waypoint-row span.index { font-weight: 600; color: #1b4fd8; }
    .waypoint-row input { width: 100%; border: 1px solid rgba(30, 60, 120, 0.16); border-radius: 8px; padding: 6px 8px; font-size: 13px; font-family: inherit; background: rgba(255, 255, 255, 0.95); }
    .waypoint-row input:focus { outline: 2px solid rgba(31, 88, 255, 0.35); outline-offset: 1px; }
    .waypoint-actions { display: flex; gap: 4px; }
    .waypoint-actions button { padding: 6px 8px; min-width: 32px; font-size: 12px; }
    .waypoint-actions .danger { background: rgba(255, 82, 82, 0.12); border-color: rgba(255, 82, 82, 0.32); color: #d12b2b; }
    .saved-routes { display: flex; flex-direction: column; gap: 10px; }
    .saved-routes h2 { font-size: 16px; margin: 0; color: #0f2350; }
    .saved-routes__list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 8px; }
    .saved-routes__item { display: flex; justify-content: space-between; align-items: center; gap: 10px; border: 1px solid rgba(37, 102, 233, 0.14); border-radius: 12px; padding: 10px 12px; background: rgba(255, 255, 255, 0.92); box-shadow: 0 4px 12px rgba(25, 68, 130, 0.08); }
    .saved-routes__item strong { display: block; font-size: 14px; color: #123a80; }
    .saved-routes__item small { display: block; font-size: 11px; color: #61718f; margin-top: 2px; }
    .saved-routes__item .saved-actions { display: flex; gap: 6px; }
    .saved-routes__item button.danger { background: rgba(255, 82, 82, 0.12); border-color: rgba(255, 82, 82, 0.32); color: #d12b2b; }
    .saved-routes__item.is-active { border-color: rgba(27, 79, 216, 0.38); box-shadow: 0 6px 18px rgba(25, 68, 130, 0.18); }
    .saved-routes__item.is-active button[data-action="load"] { background: rgba(31, 88, 255, 0.12); border-color: rgba(31, 88, 255, 0.3); color: #1b4fd8; cursor: default; pointer-events: none; }
    .route-details { display: flex; flex-direction: column; gap: 18px; }
    .sea-note { font-size: 12px; color: #61718f; line-height: 1.5; border-top: 1px solid rgba(30, 60, 120, 0.12); padding-top: 12px; margin-top: auto; }
    .route-card { background: linear-gradient(135deg, rgba(37, 102, 233, 0.08), rgba(104, 176, 255, 0.06)); border: 1px solid rgba(37, 102, 233, 0.18); border-radius: 18px; padding: 20px 20px 18px; display: flex; flex-direction: column; gap: 16px; box-shadow: 0 10px 30px rgba(25, 68, 130, 0.12); }
    .route-card.empty { background: rgba(255, 255, 255, 0.88); border-style: dashed; color: #61718f; }
    .route-card__header { display: flex; flex-direction: column; gap: 4px; }
    .route-card__header h2 { margin: 6px 0 4px; font-size: 18px; line-height: 1.3; }
    .route-card__header p { margin: 0; font-size: 13px; text-transform: uppercase; letter-spacing: 0.06em; color: #304c78; }
    .badge { display: inline-flex; align-items: center; gap: 6px; font-size: 11px; font-weight: 600; letter-spacing: 0.1em; text-transform: uppercase; color: #1b4fd8; background: rgba(37, 102, 233, 0.12); border-radius: 999px; padding: 4px 10px; }
    .leg-list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 14px; }
    .leg-list li { display: flex; flex-direction: column; gap: 4px; padding: 10px 12px; background: rgba(255, 255, 255, 0.85); border: 1px solid rgba(37, 102, 233, 0.14); border-radius: 12px; cursor: pointer; transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease; outline: none; }
    .leg-list li:hover, .leg-list li:focus { border-color: rgba(37, 102, 233, 0.4); box-shadow: 0 8px 18px rgba(25, 68, 130, 0.16); transform: translateY(-1px); }
    .leg-list li.is-active { border-color: rgba(37, 102, 233, 0.55); box-shadow: 0 10px 24px rgba(25, 68, 130, 0.2); transform: translateY(-2px); }
    .leg-line { display: flex; justify-content: space-between; align-items: flex-start; gap: 8px; }
    .leg-name { font-weight: 600; color: #0f2350; }
    .leg-meta { display: flex; justify-content: space-between; font-size: 13px; color: #486186; }
    .leg-distance { font-weight: 600; color: #123a80; }
    .leg-duration { font-variant-numeric: tabular-nums; }
    .map-wrap { position: relative; flex: 1; }
    #map { height: 100%; width: 100%; min-height: 100vh; background: #e4edf8; }
    .toolbar { position: absolute; top: 24px; right: 28px; z-index: 1000; display: flex; gap: 8px; background: rgba(255, 255, 255, 0.95); border: 1px solid rgba(30, 60, 120, 0.18); box-shadow: 0 10px 25px rgba(16, 40, 84, 0.12); border-radius: 14px; padding: 6px; backdrop-filter: blur(4px); }
    .toolbar button { cursor: pointer; border: 1px solid rgba(30, 60, 120, 0.18); background: #fff; padding: 8px 14px; border-radius: 10px; font-weight: 600; color: #1b2f53; transition: all 0.15s ease; }
    .toolbar button:hover { border-color: #1f58ff; color: #1f58ff; }
    .toolbar button.active { background: #2b7bff; color: #fff; border-color: #1f58ff; box-shadow: 0 8px 16px rgba(31, 88, 255, 0.3); }
    .legend { position: absolute; bottom: 24px; right: 28px; background: rgba(255, 255, 255, 0.94); border: 1px solid rgba(30, 60, 120, 0.16); border-radius: 12px; padding: 14px 16px; box-shadow: 0 12px 24px rgba(16, 38, 82, 0.15); font-size: 13px; line-height: 1.4; max-width: 300px; }
    .legend strong { display: block; margin-bottom: 6px; color: #0f2350; }
    .legend .swatch, .legend .swatch-alt { display: inline-block; width: 24px; height: 6px; margin-right: 6px; vertical-align: middle; border-radius: 3px; box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.15); }
    .legend .swatch { background: #1565c0; }
    .legend .swatch-alt { background: #f16161; box-shadow: 0 0 0 1px rgba(241, 97, 97, 0.4); }
    .route-label { background: rgba(255, 255, 255, 0.92); border: 1px solid rgba(37, 102, 233, 0.35); border-radius: 10px; box-shadow: 0 12px 28px rgba(16, 38, 82, 0.22); color: #10264d; padding: 6px 10px; text-align: center; font-size: clamp(11px, 0.8vw + 8px, 14px); line-height: 1.35; font-weight: 500; white-space: nowrap; }
    .route-label .tooltip-heading { font-weight: 600; }
    .route-label .tooltip-meta { font-size: 0.85em; color: #486186; }
    .route-label.is-active { border-color: rgba(37, 102, 233, 0.6); box-shadow: 0 16px 32px rgba(25, 68, 130, 0.32); }
    @media (max-width: 900px) {
      .app { flex-direction: column; }
      .sidebar { order: 2; width: 100%; max-width: none; box-shadow: none; border-bottom: 1px solid rgba(30, 60, 120, 0.12); border-radius: 0; padding: 22px 18px 24px; }
      .map-wrap { order: 1; min-height: 68vh; }
      #map { min-height: 70vh; }
      .toolbar { left: 50%; right: auto; transform: translateX(-50%); top: 18px; }
      .legend { left: 50%; right: auto; transform: translateX(-50%); bottom: 18px; }
    }
    @media (max-width: 520px) {
      .sidebar { padding: 18px 16px 22px; gap: 16px; }
      .editor { padding: 14px; }
      .waypoint-row { grid-template-columns: 24px minmax(0, 1fr); grid-template-rows: auto auto auto; }
      .waypoint-row input[name="name"] { grid-column: 2 / -1; }
      .waypoint-row input[name="lat"], .waypoint-row input[name="lng"] { grid-column: 2 / -1; }
      .waypoint-row .waypoint-actions { grid-column: 2 / -1; justify-content: flex-start; }
      .route-card { padding: 16px; border-radius: 16px; }
      .route-card__header h2 { font-size: 16px; }
      .badge { font-size: 10px; }
      .leg-list li { padding: 10px; }
      .toolbar { flex-wrap: wrap; gap: 4px; padding: 6px 10px; }
      .toolbar button { flex: 1 0 120px; }
      .legend { width: calc(100% - 32px); max-width: none; }
      .leg-meta { flex-direction: column; gap: 2px; align-items: flex-start; }
      .leg-line { flex-direction: column; align-items: flex-start; gap: 6px; }
      #map { min-height: 60vh; }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar">
      <h1>Tulip Tackers</h1>
      <p class="intro">Markermeer Routenplanung mit echten See-Distanzen. Füge Wegpunkte hinzu, ziehe sie in die richtige Reihenfolge und lasse dir automatisch eine sichere Route über tiefes Wasser berechnen.</p>

      <section class="editor">
        <label for="routeNameInput" class="field-label">Routenname</label>
        <input id="routeNameInput" type="text" placeholder="Meine Markermeer-Route" />
        <div class="editor-controls">
          <button id="addFromMapBtn" type="button">+ Wegpunkt via Karte</button>
          <button id="addManualBtn" type="button">+ Wegpunkt manuell</button>
          <button id="importGpxBtn" type="button">GPX importieren</button>
        </div>
        <div class="waypoint-list" id="waypointList"></div>
        <div class="editor-actions">
          <button id="clearRouteBtn" type="button" class="secondary">Route leeren</button>
          <button id="saveRouteBtn" type="button">Route speichern</button>
        </div>
      </section>

      <input type="file" id="gpxFileInput" accept=".gpx,application/gpx+xml" style="display:none" />

      <section class="saved-routes">
        <h2>Gespeicherte Routen</h2>
        <ul id="savedRoutesList" class="saved-routes__list"></ul>
      </section>

      <div id="routeDetails" class="route-details"></div>
      <div class="sea-note">Distanzberechnung via Haversine. Tiefgang-Check: Hindernisse &lt; 2,2&nbsp;m werden über definierte Umfahrungen gemieden. Datenbasis: vereinfachte Markermeer-Flachwasser-Polygone · Basemap: Carto Voyager &amp; OSM · Overlay: OpenSeaMap.</div>
    </aside>
    <div class="map-wrap">
      <div id="map"></div>
      <div class="legend">
        <strong>Tulip Tackers – Seekarte</strong>
        <span class="swatch"></span> Aktive Route (≥ 2,2 m erwartet)<br/>
        <span class="swatch-alt"></span> Markiertes Flachwasser (&lt; 2 m)
      </div>
    </div>
  </div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <script>
    const NM_FROM_KM = 1 / 1.852;
    const SPEED_RANGE = { min: 5, max: 7 };
    const MIN_DEPTH = 2.2;
    const ROUTE_STORE_KEY = 'tuliptackers.routes.v1';

    const defaultRoute = {
      id: 'default-hoorn-loop',
      name: 'Standard Hoorn Loop',
      waypoints: [
        { name: 'Lemmer (Enjoy Sailing)', lat: 52.846, lng: 5.708 },
        { name: 'Hoorn', lat: 52.643, lng: 5.071 },
        { name: 'Amsterdam', lat: 52.383, lng: 4.900 },
        { name: 'Urk', lat: 52.664, lng: 5.604 },
        { name: 'Lemmer (Rückkehr)', lat: 52.846, lng: 5.708 }
      ]
    };

    const shallowAreas = [
      {
        id: 'gouwzee',
        name: 'Gouwzee-Flachwasser (<2 m)',
        depth: 1.5,
        coords: [
          [52.552, 5.110],
          [52.540, 5.150],
          [52.520, 5.137],
          [52.528, 5.092]
        ],
        routeNodes: [
          [52.561, 5.085],
          [52.512, 5.063]
        ]
      },
      {
        id: 'markerwadden',
        name: 'Markerwadden-Flachwasser (<1.5 m)',
        depth: 1.5,
        coords: [
          [52.640, 5.435],
          [52.625, 5.510],
          [52.598, 5.495],
          [52.612, 5.430]
        ],
        routeNodes: [
          [52.655, 5.405],
          [52.585, 5.540]
        ]
      },
      {
        id: 'noorderoever',
        name: 'Noorderoever (<1.8 m)',
        depth: 1.8,
        coords: [
          [52.680, 5.568],
          [52.668, 5.610],
          [52.646, 5.598],
          [52.658, 5.552]
        ],
        routeNodes: [
          [52.702, 5.586],
          [52.640, 5.570]
        ]
      }
    ];

    const state = {
      currentRouteId: null,
      routeName: '',
      waypoints: [],
      requiredDepth: MIN_DEPTH
    };

    let savedRoutes = [];
    let shouldFitMap = false;
    let addFromMapArmed = false;
    let legLayers = [];
    let highlightedLegIndex = null;

    const waypointListEl = document.getElementById('waypointList');
    const routeNameInput = document.getElementById('routeNameInput');
    const addFromMapBtn = document.getElementById('addFromMapBtn');
    const addManualBtn = document.getElementById('addManualBtn');
    const importGpxBtn = document.getElementById('importGpxBtn');
    const gpxFileInput = document.getElementById('gpxFileInput');
    const saveRouteBtn = document.getElementById('saveRouteBtn');
    const clearRouteBtn = document.getElementById('clearRouteBtn');
    const savedRoutesListEl = document.getElementById('savedRoutesList');
    const routeDetailsEl = document.getElementById('routeDetails');

    const map = L.map('map', { zoomControl: true });
    map.attributionControl.setPrefix('');
    const carto = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap & CARTO'
    });
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap-Mitwirkende'
    });
    carto.on('tileerror', () => {
      if (!map.hasLayer(osm)) {
        map.addLayer(osm);
        map.removeLayer(carto);
      }
    });
    carto.addTo(map);
    const seamarks = L.tileLayer('https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
      maxZoom: 18,
      opacity: 0.95,
      attribution: '&copy; OpenSeaMap Contributors'
    }).addTo(map);
    const shallowLayer = L.layerGroup().addTo(map);
    L.control.layers(
      { 'Carto Voyager': carto, 'OpenStreetMap': osm },
      { 'OpenSeaMap Seamarks': seamarks, 'Flachwasser (<2 m)': shallowLayer },
      { collapsed: true }
    ).addTo(map);
    L.control.scale({ imperial: false }).addTo(map);
    map.setView([52.7, 5.3], 9);

    const waypointLayer = L.layerGroup().addTo(map);
    const routeLayer = L.featureGroup().addTo(map);
    const labelLayer = L.layerGroup().addTo(map);

    shallowAreas.forEach(area => {
      const ring = area.coords.map(([lat, lng]) => [lng, lat]);
      if (ring[0][0] !== ring[ring.length - 1][0] || ring[0][1] !== ring[ring.length - 1][1]) {
        ring.push(ring[0]);
      }
      area.turfPolygon = turf.polygon([ring]);
      area.routeNodes = (area.routeNodes || area.coords).map(([lat, lng]) => ({ lat, lng }));
      L.polygon(area.coords.map(([lat, lng]) => [lat, lng]), {
        color: '#f16161',
        weight: 1,
        fillOpacity: 0.2,
        dashArray: '6,4'
      }).bindTooltip(area.name, { sticky: true }).addTo(shallowLayer);
    });

    const harbors = [
      { name: 'Lemmer', lat: 52.846, lng: 5.708, info: 'Enjoy Sailing' },
      { name: 'Hoorn', lat: 52.643, lng: 5.071, info: 'Grashaven' },
      { name: 'Enkhuizen', lat: 52.703, lng: 5.294, info: 'Compagnieshaven' },
      { name: 'Amsterdam', lat: 52.383, lng: 4.900, info: 'Sixhaven / Oranjesluizen' },
      { name: 'Urk', lat: 52.664, lng: 5.604, info: 'Urkerhaven' }
    ];
    harbors.forEach(port => {
      L.marker([port.lat, port.lng], {
        icon: L.icon({
          iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
          iconRetinaUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png',
          shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png'
        })
      })
        .bindPopup(`<b>${port.name}</b><br>${port.info || ''}`)
        .bindTooltip(port.name)
        .addTo(map);
    });

    routeNameInput.addEventListener('input', event => {
      state.routeName = event.target.value;
    });

    addManualBtn.addEventListener('click', () => {
      const fallback = state.waypoints[state.waypoints.length - 1] || { lat: 52.846, lng: 5.708 };
      const defaultName = `WP ${state.waypoints.length + 1}`;
      addWaypoint({ name: defaultName, lat: fallback.lat, lng: fallback.lng }, { fitMap: state.waypoints.length < 2 });
    });

    importGpxBtn.addEventListener('click', () => {
      gpxFileInput.click();
    });

    gpxFileInput.addEventListener('change', event => {
      const file = event.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const text = e.target?.result;
          if (typeof text !== 'string') throw new Error('Ungültige GPX-Datei');
          const parsed = parseGpx(text);
          if (!parsed.waypoints.length) {
            alert('Keine verwertbaren Wegpunkte/Tracks im GPX gefunden.');
            return;
          }
          applyRoute({ id: null, name: parsed.name || 'Importierte GPX-Route', waypoints: parsed.waypoints }, { fitMap: true });
        } catch (error) {
          console.error('GPX-Import fehlgeschlagen:', error);
          alert('GPX-Import fehlgeschlagen. Bitte Datei prüfen.');
        } finally {
          gpxFileInput.value = '';
        }
      };
      reader.onerror = () => {
        alert('GPX-Datei konnte nicht gelesen werden.');
        gpxFileInput.value = '';
      };
      reader.readAsText(file);
    });

    addFromMapBtn.addEventListener('click', () => {
      addFromMapArmed = !addFromMapArmed;
      addFromMapBtn.classList.toggle('is-armed', addFromMapArmed);
      addFromMapBtn.textContent = addFromMapArmed ? 'Kartenklick zum Platzieren…' : '+ Wegpunkt via Karte';
    });

    map.on('click', event => {
      if (!addFromMapArmed) return;
      addFromMapArmed = false;
      addFromMapBtn.classList.remove('is-armed');
      addFromMapBtn.textContent = '+ Wegpunkt via Karte';
      const defaultName = `WP ${state.waypoints.length + 1}`;
      addWaypoint({
        name: defaultName,
        lat: roundCoord(event.latlng.lat),
        lng: roundCoord(event.latlng.lng)
      }, { fitMap: true });
    });

    clearRouteBtn.addEventListener('click', () => {
      state.currentRouteId = null;
      state.routeName = 'Neue Route';
      state.waypoints = [];
      shouldFitMap = true;
      renderAll();
    });

    saveRouteBtn.addEventListener('click', saveCurrentRoute);

    savedRoutesListEl.addEventListener('click', event => {
      const target = event.target.closest('button[data-action]');
      if (!target) return;
      const item = target.closest('li[data-route-id]');
      if (!item) return;
      const routeId = item.dataset.routeId;
      if (target.dataset.action === 'load') {
        const route = savedRoutes.find(r => r.id === routeId);
        if (route) {
          applyRoute(route, { fitMap: true });
          renderSavedRoutes();
        }
      } else if (target.dataset.action === 'delete') {
        if (!confirm('Route wirklich löschen?')) return;
        savedRoutes = savedRoutes.filter(r => r.id !== routeId);
        persistSavedRoutes();
        if (state.currentRouteId === routeId) {
          state.currentRouteId = null;
          state.routeName = 'Neue Route';
          state.waypoints = [];
          shouldFitMap = true;
          renderAll();
        }
        renderSavedRoutes();
      }
    });

    waypointListEl.addEventListener('input', event => {
      const row = event.target.closest('.waypoint-row');
      if (!row) return;
      const index = Number(row.dataset.index);
      if (Number.isNaN(index)) return;
      const field = event.target.getAttribute('name');
      const value = event.target.value;
      if (field === 'name') {
        updateWaypoint(index, { name: value });
      } else if (field === 'lat' || field === 'lng') {
        const numeric = parseFloat(value);
        if (!Number.isNaN(numeric)) {
          updateWaypoint(index, { [field]: roundCoord(numeric) });
        }
      }
    });

    waypointListEl.addEventListener('click', event => {
      const button = event.target.closest('button[data-action]');
      if (!button) return;
      const row = button.closest('.waypoint-row');
      if (!row) return;
      const index = Number(row.dataset.index);
      if (Number.isNaN(index)) return;
      const action = button.dataset.action;
      if (action === 'delete') {
        removeWaypoint(index);
      } else if (action === 'up') {
        moveWaypoint(index, -1);
      } else if (action === 'down') {
        moveWaypoint(index, 1);
      }
    });

    routeDetailsEl.addEventListener('mouseover', handleLegHover);
    routeDetailsEl.addEventListener('focusin', handleLegHover);
    routeDetailsEl.addEventListener('mouseleave', clearHighlightedLeg);
    routeDetailsEl.addEventListener('focusout', event => {
      if (!routeDetailsEl.contains(event.relatedTarget)) {
        clearHighlightedLeg();
      }
    });
    routeDetailsEl.addEventListener('click', handleLegHover);

    init();

    function init() {
      savedRoutes = loadRoutesFromStorage();
      if (!savedRoutes.length) {
        savedRoutes.push(defaultRoute);
        persistSavedRoutes();
      }
      applyRoute(savedRoutes[0] || defaultRoute, { fitMap: true });
      renderSavedRoutes();
      renderAll({ fitMap: true });
    }

    function addWaypoint(data, { fitMap = false } = {}) {
      const waypoint = {
        id: crypto.randomUUID ? crypto.randomUUID() : `wp-${Date.now()}-${Math.random().toString(16).slice(2)}`,
        name: data.name || `WP ${state.waypoints.length + 1}`,
        lat: roundCoord(data.lat),
        lng: roundCoord(data.lng)
      };
      state.waypoints.push(waypoint);
      shouldFitMap = shouldFitMap || fitMap;
      renderAll({ fitMap });
    }

    function updateWaypoint(index, updates) {
      const wp = state.waypoints[index];
      if (!wp) return;
      state.waypoints[index] = {
        ...wp,
        ...updates
      };
      renderAll();
    }

    function removeWaypoint(index) {
      state.waypoints.splice(index, 1);
      shouldFitMap = true;
      renderAll({ fitMap: true });
    }

    function moveWaypoint(index, offset) {
      const target = index + offset;
      if (target < 0 || target >= state.waypoints.length) return;
      const [wp] = state.waypoints.splice(index, 1);
      state.waypoints.splice(target, 0, wp);
      renderAll();
    }

    function renderAll({ fitMap = false } = {}) {
      if (fitMap) {
        shouldFitMap = true;
      }
      routeNameInput.value = state.routeName;
      renderWaypointList();
      const legs = updateRoute();
      renderRouteSummary(legs);
    }

    function renderWaypointList() {
      if (!state.waypoints.length) {
        waypointListEl.innerHTML = '<div class="waypoint-empty">Füge mindestens zwei Wegpunkte hinzu, um eine Route zu erstellen.</div>';
        return;
      }

      waypointListEl.innerHTML = state.waypoints
        .map((wp, index) => `
          <div class="waypoint-row" data-index="${index}">
            <span class="index">${index + 1}</span>
            <input type="text" name="name" value="${escapeHtml(wp.name || '')}" placeholder="Waypoint" />
            <input type="number" step="0.0001" name="lat" value="${wp.lat.toFixed(5)}" aria-label="Breite" />
            <input type="number" step="0.0001" name="lng" value="${wp.lng.toFixed(5)}" aria-label="Länge" />
            <div class="waypoint-actions">
              <button type="button" data-action="up" title="Nach oben">↑</button>
              <button type="button" data-action="down" title="Nach unten">↓</button>
              <button type="button" data-action="delete" class="danger" title="Entfernen">✕</button>
            </div>
          </div>
        `)
        .join('');
    }

    function updateRoute() {
      waypointLayer.clearLayers();
      routeLayer.clearLayers();
      labelLayer.clearLayers();
      legLayers = [];

      state.waypoints.forEach((wp, index) => {
        const marker = L.marker([wp.lat, wp.lng], { draggable: true });
        marker.bindTooltip(`${index + 1}. ${wp.name || 'Waypoint'}`, { permanent: true, direction: 'top', offset: [0, -16] });
        marker.on('dragend', event => {
          const { lat, lng } = event.target.getLatLng();
          updateWaypoint(index, { lat: roundCoord(lat), lng: roundCoord(lng) });
        });
        waypointLayer.addLayer(marker);
      });

      if (state.waypoints.length < 2) {
        return [];
      }

      const legs = [];
      for (let i = 0; i < state.waypoints.length - 1; i += 1) {
        const start = state.waypoints[i];
        const end = state.waypoints[i + 1];
        const safePoints = simplifyPath(computeSafeSegment(start, end));
        const distanceNm = Number(computePathDistance(safePoints).toFixed(1));

        const latLngs = safePoints.map(pt => [pt.lat, pt.lng]);
        const polyline = L.polyline(latLngs, {
          color: '#1565c0',
          weight: 4,
          opacity: 0.9,
          lineCap: 'round',
          lineJoin: 'round'
        });
        routeLayer.addLayer(polyline);

        const labelHtml = `<div class="route-label"><div class="tooltip-heading">${escapeHtml(start.name || 'Start')} → ${escapeHtml(end.name || 'Ziel')}</div><div class="tooltip-meta">${distanceNm} sm · ${formatDuration(distanceNm)}</div></div>`;
        const label = L.marker(polyline.getBounds().getCenter(), {
          interactive: false,
          icon: L.divIcon({ className: '', html: labelHtml, iconSize: null })
        });
        labelLayer.addLayer(label);

        const legIndex = legs.length;
        polyline.on('mouseover', () => highlightLeg(legIndex));
        polyline.on('mouseout', () => {
          if (highlightedLegIndex === legIndex) {
            clearHighlightedLeg();
          }
        });
        polyline.on('click', () => highlightLeg(legIndex));

        legLayers.push({ polyline, label });

        legs.push({
          index: legIndex,
          from: start,
          to: end,
          distanceNm,
          duration: formatDuration(distanceNm),
          via: summariseViaPoints(safePoints)
        });
      }

      if (shouldFitMap && routeLayer.getLayers().length) {
        shouldFitMap = false;
        map.fitBounds(routeLayer.getBounds().pad(0.2));
      }

      return legs;
    }

    function renderRouteSummary(legs) {
      if (!legs.length) {
        routeDetailsEl.innerHTML = '<div class="route-card empty">Noch keine Route aktiv. Füge Wegpunkte hinzu oder lade eine gespeicherte Route.</div>';
        return;
      }

      const totalNm = legs.reduce((sum, leg) => sum + leg.distanceNm, 0);
      const totalDuration = formatDuration(totalNm);

      const legHtml = legs.map(leg => {
        const viaHtml = leg.via.length ? `<div class="leg-via">${leg.via.map(text => `<span class="chip">${escapeHtml(text)}</span>`).join('')}</div>` : '';
        return `
          <li data-leg-index="${leg.index}" tabindex="0">
            <div class="leg-line">
              <div>
                <div class="leg-name">${escapeHtml(leg.from.name || 'Waypoint')} → ${escapeHtml(leg.to.name || 'Waypoint')}</div>
                <div class="leg-meta">
                  <span class="leg-distance">${leg.distanceNm} sm</span>
                  <span class="leg-duration">${leg.duration} · 5–7 kn</span>
                </div>
              </div>
            </div>
            ${viaHtml}
          </li>
        `;
      }).join('');

      routeDetailsEl.innerHTML = `
        <div class="route-card">
          <div class="route-card__header">
            <span class="badge">Route</span>
            <h2>${escapeHtml(state.routeName || 'Unbenannte Route')}</h2>
            <p>${totalNm.toFixed(1)} sm gesamt · ${totalDuration} @ 5–7 kn</p>
          </div>
          <ul class="leg-list">${legHtml}</ul>
        </div>
      `;
    }

    function highlightLeg(index) {
      if (index === highlightedLegIndex) return;
      clearHighlightedLeg();
      const layer = legLayers[index];
      if (!layer) return;
      highlightedLegIndex = index;
      layer.polyline.setStyle({ weight: 7, opacity: 1 });
      layer.polyline.bringToFront();
      const labelEl = layer.label.getElement();
      if (labelEl) {
        const node = labelEl.querySelector('.route-label');
        if (node) node.classList.add('is-active');
      }
      const item = routeDetailsEl.querySelector(`li[data-leg-index="${index}"]`);
      if (item) item.classList.add('is-active');
    }

    function clearHighlightedLeg() {
      if (highlightedLegIndex === null) return;
      const layer = legLayers[highlightedLegIndex];
      if (layer) {
        layer.polyline.setStyle({ weight: 4, opacity: 0.9 });
        const labelEl = layer.label.getElement();
        if (labelEl) {
          const node = labelEl.querySelector('.route-label');
          if (node) node.classList.remove('is-active');
        }
      }
      const activeItem = routeDetailsEl.querySelector('li.is-active');
      if (activeItem) activeItem.classList.remove('is-active');
      highlightedLegIndex = null;
    }

    function handleLegHover(event) {
      const item = event.target.closest('li[data-leg-index]');
      if (!item) return;
      highlightLeg(Number(item.dataset.legIndex));
    }

    function saveCurrentRoute() {
      if (state.waypoints.length < 2) {
        alert('Bitte mindestens zwei Wegpunkte setzen, bevor du speicherst.');
        return;
      }
      const trimmedName = (state.routeName || '').trim();
      if (!trimmedName) {
        state.routeName = `Route ${new Date().toLocaleString('de-DE')}`;
      }
      const payload = {
        id: state.currentRouteId || `route-${Date.now()}`,
        name: state.routeName,
        waypoints: state.waypoints.map(wp => ({ name: wp.name, lat: wp.lat, lng: wp.lng }))
      };
      const existingIndex = savedRoutes.findIndex(route => route.id === payload.id);
      if (existingIndex >= 0) {
        savedRoutes[existingIndex] = payload;
      } else {
        savedRoutes.push(payload);
      }
      state.currentRouteId = payload.id;
      persistSavedRoutes();
      renderSavedRoutes();
      renderAll();
    }

    function applyRoute(route, { fitMap = false } = {}) {
      state.currentRouteId = route?.id || null;
      state.routeName = route?.name || 'Neue Route';
      state.waypoints = (route?.waypoints || []).map(wp => ({
        id: crypto.randomUUID ? crypto.randomUUID() : `wp-${Date.now()}-${Math.random().toString(16).slice(2)}`,
        name: wp.name,
        lat: roundCoord(wp.lat),
        lng: roundCoord(wp.lng)
      }));
      shouldFitMap = shouldFitMap || fitMap;
      renderAll({ fitMap });
    }

    function renderSavedRoutes() {
      if (!savedRoutes.length) {
        savedRoutesListEl.innerHTML = '<li class="waypoint-empty">Noch keine gespeicherten Routen.</li>';
        return;
      }
      savedRoutesListEl.innerHTML = savedRoutes.map(route => {
        const distance = estimateRouteDistance(route.waypoints);
        const isActive = route.id === state.currentRouteId;
        return `
          <li class="saved-routes__item${isActive ? ' is-active' : ''}" data-route-id="${route.id}">
            <div>
              <strong>${escapeHtml(route.name)}</strong>
              <small>${route.waypoints.length} WPs · ${distance.toFixed(1)} sm</small>
            </div>
            <div class="saved-actions">
              <button type="button" data-action="load">${isActive ? 'Aktiv' : 'Öffnen'}</button>
              <button type="button" data-action="delete" class="danger">Löschen</button>
            </div>
          </li>
        `;
      }).join('');
    }

    function loadRoutesFromStorage() {
      try {
        const raw = localStorage.getItem(ROUTE_STORE_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed)) {
          return parsed;
        }
        return [];
      } catch (error) {
        console.warn('Konnte gespeicherte Routen nicht laden:', error);
        return [];
      }
    }

    function persistSavedRoutes() {
      try {
        localStorage.setItem(ROUTE_STORE_KEY, JSON.stringify(savedRoutes));
      } catch (error) {
        console.warn('Konnte Routen nicht speichern:', error);
      }
    }

    function parseGpx(xmlString) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(xmlString, 'application/xml');
      const gpxError = doc.querySelector('parsererror');
      if (gpxError) {
        throw new Error('GPX konnte nicht geparst werden');
      }

      const name = doc.querySelector('gpx > name, metadata > name, trk > name, rte > name')?.textContent?.trim();

      const extractPoints = (nodes, defaultPrefix) => {
        const list = [];
        nodes.forEach((node, index) => {
          const lat = parseFloat(node.getAttribute('lat'));
          const lng = parseFloat(node.getAttribute('lon'));
          if (Number.isNaN(lat) || Number.isNaN(lng)) return;
          const childName = node.querySelector('name')?.textContent?.trim();
          list.push({
            name: childName || `${defaultPrefix} ${index + 1}`,
            lat,
            lng
          });
        });
        return list;
      };

      const trackPoints = extractPoints(doc.querySelectorAll('trk > trkseg > trkpt'), 'Trackpunkt');
      const routePoints = extractPoints(doc.querySelectorAll('rte > rtept'), 'Routepunkt');
      const waypointPoints = extractPoints(doc.querySelectorAll('wpt'), 'Wegpunkt');

      let waypoints = trackPoints.length ? trackPoints : routePoints;
      if (!waypoints.length) {
        waypoints = waypointPoints;
      }
      if (waypoints.length < 2) {
        return { name, waypoints: [] };
      }
      const deduped = waypoints.reduce((acc, wp) => {
        if (!acc.length || !pointsEqual(acc[acc.length - 1], wp)) {
          acc.push({ name: wp.name, lat: roundCoord(wp.lat), lng: roundCoord(wp.lng) });
        }
        return acc;
      }, []);
      return { name, waypoints: deduped };
    }

    function computeSafeSegment(startPoint, endPoint, visited = new Set()) {
      const start = clonePoint(startPoint);
      const end = clonePoint(endPoint);
      const directLine = turf.lineString([toLngLat(start), toLngLat(end)]);
      const blockingAreas = shallowAreas.filter(area => area.depth < state.requiredDepth && !turf.booleanDisjoint(directLine, area.turfPolygon));

      if (!blockingAreas.length) {
        return [start, end];
      }

      let best = null;
      blockingAreas.forEach(area => {
        const marker = `${area.id}:${start.lat}:${start.lng}:${end.lat}:${end.lng}`;
        if (visited.has(marker)) {
          return;
        }
        const nextVisited = new Set(visited);
        nextVisited.add(marker);
        area.routeNodes.forEach(node => {
          const corner = clonePoint(node);
          if (pointsEqual(start, corner) || pointsEqual(end, corner)) {
            return;
          }
          const pathToCorner = computeSafeSegment(start, corner, nextVisited);
          const pathFromCorner = computeSafeSegment(corner, end, nextVisited);
          if (!pathToCorner || !pathFromCorner) return;
          const combined = mergeSegments(pathToCorner, pathFromCorner);
          if (pathCrossesForbidden(combined)) return;
          const distance = computePathDistance(combined);
          if (!best || distance < best.distance) {
            best = { points: combined, distance };
          }
        });
      });

      return best ? best.points : [start, end];
    }

    function computePathDistance(points) {
      let total = 0;
      for (let i = 1; i < points.length; i += 1) {
        total += haversineNm(points[i - 1], points[i]);
      }
      return total;
    }

    function summariseViaPoints(points, limit = 3) {
      if (!points || points.length <= 2) return [];
      const inner = points.slice(1, -1);
      if (!inner.length) return [];
      if (inner.length <= limit) {
        return inner.map(formatPointLabel);
      }
      const sampled = [];
      const step = (inner.length - 1) / (limit - 1);
      for (let i = 0; i < limit; i += 1) {
        const idx = Math.round(i * step);
        sampled.push(inner[Math.min(idx, inner.length - 1)]);
      }
      return sampled.map(formatPointLabel);
    }

    function formatPointLabel(point) {
      return `${point.lat.toFixed(3)}°N · ${point.lng.toFixed(3)}°E`;
    }

    function mergeSegments(a, b) {
      if (!a.length) return b.slice();
      const merged = a.slice();
      for (let i = 1; i < b.length; i += 1) {
        merged.push(clonePoint(b[i]));
      }
      return merged;
    }

    function simplifyPath(points) {
      const simplified = [];
      points.forEach(point => {
        if (!simplified.length || !pointsEqual(simplified[simplified.length - 1], point)) {
          simplified.push(clonePoint(point));
        }
      });
      return simplified;
    }

    function pathCrossesForbidden(points) {
      for (let i = 1; i < points.length; i += 1) {
        const line = turf.lineString([toLngLat(points[i - 1]), toLngLat(points[i])]);
        for (const area of shallowAreas) {
          if (area.depth >= state.requiredDepth) continue;
          if (!turf.booleanDisjoint(line, area.turfPolygon)) {
            return true;
          }
        }
      }
      return false;
    }

    function estimateRouteDistance(waypoints) {
      if (!Array.isArray(waypoints) || waypoints.length < 2) return 0;
      let total = 0;
      for (let i = 1; i < waypoints.length; i += 1) {
        const start = waypoints[i - 1];
        const end = waypoints[i];
        const path = simplifyPath(computeSafeSegment(start, end));
        total += computePathDistance(path);
      }
      return total;
    }

    function haversineNm(a, b) {
      const dLat = toRad(b.lat - a.lat);
      const dLng = toRad(b.lng - a.lng);
      const lat1 = toRad(a.lat);
      const lat2 = toRad(b.lat);
      const sinLat = Math.sin(dLat / 2);
      const sinLng = Math.sin(dLng / 2);
      const h = sinLat * sinLat + Math.cos(lat1) * Math.cos(lat2) * sinLng * sinLng;
      const c = 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
      return 6371.0088 * c * NM_FROM_KM;
    }

    function toRad(value) {
      return value * Math.PI / 180;
    }

    function clonePoint(point) {
      return { lat: Number(point.lat), lng: Number(point.lng) };
    }

    function toLngLat(point) {
      return [point.lng, point.lat];
    }

    function pointsEqual(a, b) {
      return Math.abs(a.lat - b.lat) < 1e-6 && Math.abs(a.lng - b.lng) < 1e-6;
    }

    function roundCoord(value) {
      return Math.round(value * 1e6) / 1e6;
    }

    function formatDuration(distanceNm) {
      const fast = (distanceNm / SPEED_RANGE.max).toFixed(1);
      const slow = (distanceNm / SPEED_RANGE.min).toFixed(1);
      return `${fast}–${slow} h`;
    }

    function escapeHtml(value) {
      return (value || '').replace(/[&<>"]/g, char => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;' }[char] || char));
    }
  </script>
</body>
</html>
